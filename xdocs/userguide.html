<html>

<head>
<style>
.style1 {
	font-family: "Courier New", Courier, mono;
	font-size: 14px;
	color: #990000;
}
</style>
</head>
<body>

<h1><font size="6">Simple User Guide for Apache Sandesha</font></h1>
<p>This is the primary version of the user guide for Apache Sandesha. The rest 
of the document will guide you through the configuration of Sandesha and finally 
to run the sample scenarios.</p>
<h2><font size="5">Configuration</font></h2>
<p>Configuration of Apache Sandesha can be described in three steps.</p>
<ul type="square">
  <li>Checkout the code</li>
  <li>Run the Maven (Compile)</li>
  <li>use <font color="#FF0000">&nbsp;</font>Sandesha-1.0.jar </li>
</ul>
<p>So as the first step let's focus on how to configure Sandesha and run the 
sample tests. Following steps will guide you through the process.</p>
<h3><font size="4">Check out Sandesha</font></h3>
<p>Apache Sandesha is available for download as source. Please follow the CVS 
instruction to download the code
<a href="http://ws.apache.org/ws-fx/sandesha/cvs-usage.html">
http://ws.apache.org/ws-fx/sandesha/cvs-usage.html</a></p>
<h3>Build Using Apache Maven</h3>
<p>Once you have the so</p>
<p>Note : Sandesha build process is done using Apache Maven. So assume that the 
user has already configured Maven in his machine. </p>
<p>Build process is mainly to run a single Maven command and it is</p>
<p>
<source>maven</source></p>
<p>Once the build process is completed you&nbsp; can find <b>Sandesha-1.0.jar</b> 
under target directory. </p>
<p>Ok now let us see how we can use Sandesha in the client side of your 
application and also in the server side. The following section of this user 
guide will explain them in details.</p>
<h2><font size="5">Use Sandesha in the Client Side</font></h2>
<p>Following two steps will enable the usage of Sandesha in the Client Side. 
(Assume that you have build Sandesha using Maven)</p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to your class path</li>
  <li>Copy the <b>config/client-config.wsdd</b> to the class path of your 
  client. </li>
</ul>
<p>To enable Sandesha in the client side, the only requirement is to use 
<b>RMTransport</b> as the transport in the <b>client-config.wsdd.</b> If you 
copy the <b>client-config.wsdd</b> found under config directory 
then it is already configured with this property and ready to use.</p>
<p>Note: please add the jars, that are there in the target/lib to your class 
path.</p>
<p>There are two main ways that one can use axis to write web service client 
applications.</p>
<ol>
  <li>1. Using generated Stubs</li>
  <li>2. Using Dynamic Invocation Interface (DII)</li>
</ol>
<p>At the moment when you generate the stubs there is no way that we can inform 
the apache tool (wsdl2java) to generate stubs that are Sandesha aware and hence 
we need to use the DII in order to use Sandesha in the client side. However if 
there are existing stubs, then to use Sandesha with them then the user has to 
manually edit the stubs generated to insert some properties to the call object. 
We will see one example of this nature as well.</p>
<h3>Simple  Request-Response&nbsp;Client</h3>
<p>To simply use Sandesha in the client side, user has to add few lines to the 
existing client. Following code fragment shows the required additions that one 
should make. </p>
<p><source>public static void main(String[] args) {
try {
<span style="background-color: #CCCCCC">RMInitiator.initClient</span><span style="background-color: #CCCCCC">();</span>

Service service = new Service();
Call call = (Call) service.createCall();

<span style="background-color: #CCCCCC">call.setTransport(new</span><span style="background-color: #CCCCCC">
</span><span style="background-color: #CCCCCC">RMTransport(&quot;http</span><span style="background-color: #CCCCCC">://localhost:8080/axis/services/</span><span style="background-color: #CCCCCC">RMInteropService</span><span style="background-color: #CCCCCC">&quot;, 
&quot;&quot;));</span>
call.setProperty(Constants.ClientProperties.ACTION, &quot;urn:wsrm:echoString&quot;);

call.setTargetEndpointAddress(&quot;http://localhost:8080/axis/services/RMInteropService&quot;);
call.setOperationName(new QName(&quot;http://tempuri.org/&quot;, &quot;echoString&quot;));
call.addParameter(&quot;arg1&quot;, XMLType.XSD_STRING, ParameterMode.IN);
call.addParameter(&quot;arg2&quot;, XMLType.XSD_STRING, ParameterMode.IN);
call.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);

<span style="background-color: #CCCCCC">
call.setProperty(Constants.ClientProperties.LAST_MESSAGE</span><span style="background-color: #CCCCCC">, 
new </span><span style="background-color: #CCCCCC">Boolean(true</span><span style="background-color: #CCCCCC">));</span>

String ret = (String) call.invoke(new Object[]{&quot;Sandesha Echo 1&quot;, &quot;abcdef&quot;});
System.out.println(&quot;The Response for First Messsage is :&quot; + ret);

<span style="background-color: #CCCCCC">RMInitiator.stopClient</span><span style="background-color: #CCCCCC">();</span>
} catch (Exception e) {
e.printStackTrace();
}
}
&nbsp;</source></p>
<h4>Explanation on Additions :</h4>
<p>
<span style="background-color: #CCCCCC; font-weight:700">RMInitiator.initClient();</span></p>
<p>This step initializes the&nbsp; RMSource (Client side ReliableMessaging 
Endpoint). This will start the Sender and the client side listener for this 
inovcation.</p>
<p>
<span style="background-color: #CCCCCC; font-weight:700">call.setTransport(new RMTransport(&quot;http://localhost:8080/axis/services/RMInteropService&quot;, 
&quot;&quot;));</span></p>
<p>Sandesha uses RMTransport, which will add the out going messages to Sandesha 
Queue, in the client side. This line is used to inform the axis engine to use 
RMTransport as the transport sender for this invocation. In addition axis 
requires the following lines to be there in the client-config.wsdd.</p>
<p><source>&lt;handler name=&quot;RMSender&quot; type=&quot;java:org.apache.sandesha.client.RMSender&quot;/&gt;<br>
&lt;transport name=&quot;RMTransport&quot; pivot=&quot;RMSender&quot;/&gt;</source> </p>
<p>
<span style="background-color: #CCCCCC; font-weight:700">
call.setProperty(Constants.ClientProperties.LAST_MESSAGE, 
new Boolean(true));</span></p>
<p>This is to inform the RMSource that this message is the last message of a 
particular sequence. Meaning of this statement may not be trivial in the case of 
a single message scenario as above, however this is a &quot;REQUIRED&quot; property for 
RMSource to add the &lt;wsrm:LastMessage&gt; header to the outgoing message.</p>
<p>
<span style="background-color: #CCCCCC; font-weight:700">RMInitiator.stopClient();</span></p>
<p>This is the last statment relating to this invocation sequence. RMSource will 
wait till all the sequence to be complete before passing the control back to the 
client code. The wait time depends on the policy assertion InactivityTimeout( &lt;wsrm:InactivityTimeout 
Milliseconds=&quot;60000&quot; /&gt; ). Once all the messages are sent and the 
responses (if any) are received then this will stop the client side listener and 
clean up the Sandesha Queue.</p>
<p>Note : These are the minimum changes that one should do in-order to use 
Sandesha in the client side. There are some other additions that one can use to 
get more flexibility in Sandesha and we will see them in the following examples.</p>
<h3>Simple  One Way Client</h3>
<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation. Again the following code fragment will explain the 
additional code lines required. For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<p><source>
public static void main(String[] args) {
try {

<span style="background-color: #CCCCCC">RMInitiator.initClient();</span>

Service service = new Service();
Call call = (Call) service.createCall();

<span style="background-color: #CCCCCC">call.setTransport(new RMTransport("http://localhost:8070/axis/services/RMInteropService", ""));</span> 
call.setProperty(Constants.ClientProperties.ACTION, "urn:wsrm:Ping");

call.setTargetEndpointAddress("http://localhost:8070/axis/services/RMInteropService");
call.setOperationName(new QName("http://tempuri.org/", "ping"));
call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);

call.invoke(new Object[]{"Sandesha Ping 1"});
call.invoke(new Object[]{"Sandesha Ping 2"});
<span style="background-color: #CCCCCC">call.setProperty(Constants.ClientProperties.LAST_MESSAGE, new Boolean(true));</span> 
call.invoke(new Object[]{"Sandesha Ping 3"});

<span style="background-color: #CCCCCC">RMInitiator.stopClient();
</span>} catch (Exception e) { e.printStackTrace();
}
}
</source></p>

<p>As it can be seen, we need the same additions as above and the explanations 
are the same.</p>

<h3>Simple  One Way Client (Synchronous Acknowledgements)</h3>

<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation using same transport channel to get acknowledgements.&nbsp; For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<p><source>
public static void main(String[] args) {
try {

<span style="background-color: #CCCCCC">RMInitiator.initClient(</span><span style="background-color: #FFFF99">true</span><span style="background-color: #CCCCCC">);</span>

Service service = new Service();
Call call = (Call) service.createCall();

<span style="background-color: #CCCCCC">call.setTransport(new RMTransport("http://localhost:8070/axis/services/RMInteropService", ""));</span>
<span style="background-color: #FFFF99">call.setProperty(Constants.ClientProperties.SYNC, new Boolean(true));</span> 
call.setProperty(Constants.ClientProperties.ACTION, "urn:wsrm:Ping");

call.setTargetEndpointAddress("http://localhost:8070/axis/services/RMInteropService");
call.setOperationName(new QName("http://tempuri.org/", "ping"));
call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);

call.invoke(new Object[]{"Sandesha Ping 1"});
call.invoke(new Object[]{"Sandesha Ping 2"});
<span style="background-color: #CCCCCC">call.setProperty(Constants.ClientProperties.LAST_MESSAGE, new Boolean(true));</span> 
call.invoke(new Object[]{"Sandesha Ping 3"});

<span style="background-color: #CCCCCC">RMInitiator.stopClient();
</span>} catch (Exception e) { e.printStackTrace();
}
}
</source></p>

<p>We need two more changes and the explanations are as follows.</p>

<p><b><span style="background-color: #CCCCCC">RMInitiator.initClient();</b></span>

<p>By these, client can inform the RMSource, not to start a separate client side 
listener and send the requests with &quot;<b>anonymous URI</b>&quot; in &lt;wsa:From&gt; and &lt;wsrm:AcksTo&gt;&nbsp; 
headers. So the server will use the same transport connection to send Create 
Sequence Response and Acknowledgements.</p>

<p>Note: Please note that this can only be used for One-way operations. If the 
web service request has a response then Sandesha always use a separate listener 
to retrieve the response back.</p>

<p><b><span style="background-color: #FFFF99">
call.setProperty(Constants.ClientProperties.SYNC</span><span style="background-color: #FFFF99">, 
new Boolean(true));</span></b></p>

<p>This is the line that informs&nbsp; RMSource to use anonymous &lt;wsa&gt; headers 
for request messages.</p>

<h3>Overriding the wsa:Addressing and Other Parameters from Client</h3>

<p>In this section we will look at how we can override the properties specific 
to Sandesha from the client code itself. Sandesha provides complete flexibility 
to the user by allowing them to override properties that are used to set various 
message headers. However it is important to note that the user should set 
appropriate properties (depending on the client, either request-response or one 
way) to get the correct functionality. Following code fragment contains all the 
parameters that the client can set inside the client code.</p>

<p><sourc>
call.setProperty(Constants.ClientProperties.TO,"http://test.organization.com:8080/wsrm/services/rmDemos");
call.setProperty(Constants.ClientProperties.ACKS_TO,"http://our.organization.org:9070/axis/services/RMService");
call.setProperty(Constants.ClientProperties.FAULT_TO, "http://our.organization.org:9070/axis/services/RMService"); 
call.setProperty(Constants.ClientProperties.FROM, "http://our.organization.org:9070/axis/services/RMService");
call.setProperty(Constants.ClientProperties.REPLY_TO, "http://our.organization.org:9070/axis/services/RMService");
call.setProperty(Constants.ClientProperties.SEND_OFFER,new Boolean(true));
</source></p>

<p>These properties are very useful when debugging applications. By changing 
them appropriately the user can route messages through TCP Monitor or some 
monitor. These properties are self explanatory and hence let's look at one more 
sample with properties to route all the messages through TCP Monitor. Let's use 
Request/Response type service Invocation.</p>

<h2><font size="5">To Use Sandesha in the Server Side</font></h2>
<p>This can again be done using two steps.</p>
<p>Assume that axis is configured in Tomcat Server </p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to the <b>CATALINA_HOME/webapps/axis/WEB-INF/lib</b> along 
with the other new jars that can be found in <b>target/lib</b> directory of Sandesha.</li>
  <li>To configure Sandesha for a particular service( say MyService) change the 
  <b>deploy.wsdd</b> of <b>&nbsp;MyService</b> according to the following.</li>
</ul>
<source>
<p>&lt;deployment xmlns=&quot;<a href="http://xml.apache.org/axis/wsdd/">http://xml.apache.org/axis/wsdd/</a>&quot; xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;</p>
<p>&lt;service name=&quot;MyService&quot; provider=&quot;Handler&quot;&gt;</p>
<p>&lt;requestFlow&gt;</p>
<p>&lt;handler type=&quot;java:org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler&quot;&gt;&lt;/handler&gt;</p>
<p>&lt;handler type=&quot;java:org.apache.axis.message.addressing.handler.AddressingHandler&quot;&gt;&lt;/handler&gt;</p>
<p>&lt;/requestFlow&gt;</p>
<p>&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.apache.sandesha.ws.rm.providers.RMProvider&quot;/&gt;</p>
<p>&lt;parameter name=&quot;className&quot; value=&quot;test.MyService&quot;/&gt;</p>
<p>&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;</p>
<p>&lt;parameter name=&quot;scope&quot; value=&quot;request&quot;/&gt;</p>
<p>&lt;/service&gt;</p>
<p>&lt;/deployment&gt;</p></source>
<p>Note that we have to change the provider to <b>RMProvider</b> and need to add two 
request handlers. A sample of this <b>deploy.wsdd</b> can be found in the interop 
directory named <b>RMInteropServiceDeploy</b> with the required bat file to deploy the 
service. (make sure that the classes for the <b>MyService</b> is copied to 
<b>CATALINA_HOME/webapps/axis/WEB-INF/classes. RMProvider</b> by default will 
use the <b>RPCProvider</b> to invoke the services, however user can specify the 
actual provider that is required to invoke a particular service in <b>
sandesha.properties</b> file that can be found in <b>config</b> directory.</p>
<p>&nbsp;</p>

<h2>Interop Testing</h2>

<h3>Build the Interop Classes</h3>
<p>Note : Sandesha build process is done using Apache Maven. So assume that the 
user has already configured Maven in his machine. </p>
<p>Build process is mainly to run a single Maven command and it is</p>
<p>
<source>maven</source></p>
<p>Since we need the samples also to be build we need one more command</p>
<p>
<source>maven interop:compile</source></p>
<p>If you need a project to be created for eclipse or Intellij IDEA use the 
maven commands</p>
<p>
<source>maven eclipse</source> </p>
<p><source>maven idea</source> </p>
<h3><font size="4">Run the Inter-op Samples</font></h3>
<p>Go to the directory, interop under the main directory tree. To run the sample 
scenarios we only need to type simple ant commands in a command line.</p>
<p>Followings are the commands to run the samples scenarios.</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="13%">Ant command</td>
    <td width="87%">&nbsp;Description</td>
  </tr>
  <tr>
    <td width="13%">ping_sync</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in same HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">ping_async</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in a different&nbsp; HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_sync_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request and the response&nbsp; come in&nbsp; 
different HTTP Connections. Acknowledgements are coming in the response path of 
    the request's HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_async_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request Acknowledgement and the response&nbsp; come in&nbsp; 
different HTTP Connections.</td>
  </tr>
</table>
<p>In all these scenarios the service <b>RMInteropService</b> is deployed in a
<b>SimpleAxisServer</b> using the ant script and the results will be shown in TCP 
monitors. Please check whether the java processes that is used to invoke TCP 
monitors are not running in the back ground, before every test.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>