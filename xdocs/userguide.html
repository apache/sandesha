<html>

<head>
<style>
.style1 {
	font-family: "Courier New", Courier, mono;
	font-size: 14px;
	color: #990000;
}
</style>
</head>
<body>

<h1><font size="6">User Guide for Apache Sandesha</font></h1>
<p>This document&nbsp; will guide you through the configuration of Sandesha and finally 
to run the sample scenarios.</p>
<h2><font size="5">Configuration</font></h2>
<p>Configuration of Apache Sandesha can be described in three steps.</p>
<ul type="square">
  <li>Checkout the code</li>
  <li>Run the Maven (Compile)</li>
  <li>use <font color="#FF0000">&nbsp;</font>Sandesha-1.0.jar </li>
</ul>
<p>So as the first step let's focus on how to configure Sandesha and run the 
sample tests. Following steps will guide you through the process.</p>
<h3><font size="4">Check out Sandesha</font></h3>
<p>Apache Sandesha is available for download as source. Please follow the CVS 
instruction to download the code
<a href="http://ws.apache.org/ws-fx/sandesha/cvs-usage.html">
http://ws.apache.org/ws-fx/sandesha/cvs-usage.html</a></p>
<h3>Build Using Apache Maven</h3>
<p>Once you have the so</p>
<p>Note : Sandesha build process is done using Apache Maven. So assume that the 
user has already configured Maven in his machine. </p>
<p>Build process is mainly to run a single Maven command and it is</p>
<p>
<source>maven</source></p>
<p>Once the build process is completed you&nbsp; can find <b>Sandesha-1.0.jar</b> 
under target directory. </p>
<p>Ok now let us see how we can use Sandesha in the client side of your 
application and also in the server side. The following section of this user 
guide will explain them in details.</p>
<h2><font size="5">Use Sandesha in the Client Side</font></h2>
<p>Following two steps will enable the usage of Sandesha in the Client Side. 
(Assume that you have build Sandesha using Maven)</p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to your class path</li>
  <li>Copy the <b>config/client-config.wsdd</b> to the class path of your 
  client. </li>
</ul>
<p>To enable Sandesha in the client side, the only requirement is to use 
<b>RMTransport</b> as the transport in the <b>client-config.wsdd.</b> If you 
copy the <b>client-config.wsdd</b> found under config directory 
then it is already configured with this property and ready to use.</p>
<p>Note: please add the jars, that are there in the target/lib to your class 
path.</p>
<p>There are two main ways that one can use axis to write web service client 
applications.</p>
<ol>
  <li>1. Using Generated Stubs</li>
  <li>2. Using Dynamic Invocation Interface (DII)</li>
</ol>
<p>At the moment when you generate the stubs there is no way that we can inform 
the apache tool (wsdl2java) to generate stubs that are Sandesha aware and hence 
we need to use the DII in order to use Sandesha in the client side. However if 
there are existing stubs, then to use Sandesha with them then the user has to 
manually edit the stubs generated to insert some properties to the call object. 
We will see one example of this nature as well.</p>
<h3>Simple  Request-Response&nbsp;Client</h3>
<p>To simply use Sandesha in the client side, user has to add few lines to the 
existing client. Following code fragment shows the required additions that one 
should make. </p>
<p><source>public static void main(String[] args) {
try {
Service service = new Service();
Call call = (Call) service.createCall();
<span style="background-color: #CCCCCC">SandeshaContext ctx = new SandeshaContext();</span>
<span style="background-color: #CCCCCC">ctx.addNewSequeceContext(call, targetUrl,
			 "urn:wsrm:echoString",Constants.ClientProperties.IN_OUT);</span>
call.setOperationName(new QName("http://tempuri.org/", "echoString"));
call.addParameter("Text", XMLType.XSD_STRING, ParameterMode.IN);
call.addParameter("Seq", XMLType.XSD_STRING, ParameterMode.IN);
call.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);

<span style="background-color: #CCCCCC">ctx.setLastMessage(call);</span>
String ret = (String) call.invoke(new Object[]{"Sandesha Echo 1", "abcdef"});
System.out.println("The Response for First Messsage is :" + ret);

<span style="background-color: #CCCCCC">ctx.endSequence(call);</span>
} catch (Exception e) { e.printStackTrace();
}
}</source></p>
<h4>Explanation on Additions :</h4>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">SandeshaContext ctx = new SandeshaContext();</span></p>
<p>This is the initial step in initializing the&nbsp; RMSource (Client side ReliableMessaging 
Endpoint). SandeshaContext is used to keep track of different sequences that the 
client may create throughout the its lifecycle. Client can &quot;add&quot; any number of 
sequences and &quot;end&quot; them in any order.</p>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">ctx.addNewSequeceContext(call,targetUrl ,
                    "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY);</span></p>
<p>Using this step the client can add the call object to the SandeshaContext, 
with targetUrl,&lt;wsa:Action&gt; and the Message Exchange Pattern (MEP) as the 
parameters. Target URL and the action are self-explanatory but may be not the 
MEP. MEP informs Sandesha end point the behavior of the message exchange 
expected by this call object. In other words it helps SandeshaContext to 
understand whether the call object is used for a &quot;Request/Response&quot;&nbsp; 
invocation or &quot;Request Only&quot; invocation. <br>
&nbsp;</p>
<p><span style="font-weight: 700; background-color: #CCCCCC">ctx.setLastMessage(call);</span></p>
<p>This is to inform the RMSource that this message is the last message of a 
particular sequence. Meaning of this statement may not be trivial in the case of 
a single message scenario as above, however this is a &quot;REQUIRED&quot; property for 
RMSource&nbsp; and this will add the &lt;wsrm:LastMessage&gt; header to the outgoing message.</p>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">ctx.endSequence(call);</span></p>
<p>This is the last statement relating to this invocation sequence. RMSource will 
wait till all the messages been acknowledged and the terminate sequence for this 
particular sequence is sent, before returning the control back to the invocation 
party (that is client). The wait time depends on the policy assertion InactivityTimeout( &lt;wsrm:InactivityTimeout 
Milliseconds=&quot;60000&quot; /&gt; ). If this is the final sequence that is 
available for stopping then the context will wait till all the messages are sent and the 
responses (if any) are received and will stop the client side listener and 
clean up the Sandesha Queue.</p>
<p>Note : These are the minimum changes that one should do in-order to use 
Sandesha in the client side. There are some other additions that one can use to 
get more flexibility in Sandesha and we will see them in the following examples.</p>
<h3>Simple  One-Way Client</h3>
<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation. Again the following code fragment will explain the 
additional code lines required. For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<p><source>public static void main(String[] args) {
try {
Service service = new Service();
Call call = (Call) service.createCall();

SandeshaContext ctx = new SandeshaContext();
ctx.addNewSequeceContext(call,targetUrl ,
                    "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY);
call.setOperationName(new QName("http://tempuri.org/", "ping"));
call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);
            
call.invoke(new Object[]{"Sandesha Ping 1"});
call.invoke(new Object[]{"Sandesha Ping 2"});
ctx.setLastMessage(call);
call.invoke(new Object[]{"Sandesha Ping 3"});
ctx.endSequence(call);

} catch (Exception e) {
   e.printStackTrace();
}
}</source></p>

<p>As it can be seen, we need the same additions as above and the explanations 
are the same.</p>

<h3>Simple  One Way Client (Synchronous Acknowledgements)</h3>

<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation using same transport channel to get acknowledgements.&nbsp; For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<p><source>
public static void main(String[] args) {
try {
Service service = new Service();
Call call = (Call) service.createCall();

SandeshaContext ctx = new SandeshaContext();
<span style="background-color: #CCCCCC">ctx.addNewSequeceContext(call,targetUrl ,
	   "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY,</span><span style="background-color: #FFFF99">true</span>);

call.setOperationName(new QName("http://tempuri.org/", "ping"));
call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);

call.invoke(new Object[]{"Sandesha Ping 1"});
call.invoke(new Object[]{"Sandesha Ping 2"});
ctx.setLastMessage(call);
call.invoke(new Object[]{"Sandesha Ping 3"});
ctx.endSequence(call);

} catch (Exception e) {
   e.printStackTrace();
}
}</source></p>

<p>The only change we need is to set the flag &quot;sync&quot; to &quot;true&quot; when we add the 
sequence to SandeshaContext, as shown bellow.</p>

<p><b>
<span style="background-color: #CCCCCC">ctx.addNewSequeceContext(call,targetUrl ,
                        "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY,</span><span style="background-color: #FFFF99">true</span>);</b><p>By these, client can inform the RMSource, not to start a separate client side 
listener and send the requests with &quot;<b>anonymous URI</b>&quot; in &lt;wsa:From&gt; and &lt;wsrm:AcksTo&gt;&nbsp; 
headers. So the server will use the same transport connection to send Create 
Sequence Response and Acknowledgements.</p>

<p>Note: Please note that this can only be used for One-way operations. If the 
web service request has a response then Sandesha always use a separate listener 
to retrieve the response back.</p>

<h3>Overriding the wsa:Addressing and Other Parameters from Client</h3>

<p>In this section we will look at how we can override the properties specific 
to Sandesha from the client code itself. Sandesha provides complete flexibility 
to the user by allowing them to override properties that are used to set various 
message headers. However it is important to note that the user should set 
appropriate properties (depending on the client, either request-response or one 
way) to get the correct functionality. Following code fragment contains all the 
parameters that the client can set inside the client code.</p>

<p><source>
ctx.setToUrl(call, "http://test.organization.com:8080/wsrm/services/rmDemos");
ctx.setFromUrl(call, "http://our.organization.org:9070/axis/services/RMService");
ctx.setReplyToUrl(call, "http://our.organization.org:9070/axis/services/RMService");
ctx.setAcksToUrl(call, "http://our.organization.org:9070/axis/services/RMService");
ctx.setFaultToUrl(call, "http://our.organization.org:9070/axis/services/RMService");
ctx.setSendOffer(call);</source></p>

<p>These properties are very useful when debugging applications. By changing 
them appropriately the user can route messages through TCP Monitor or some 
monitor. These properties are self explanatory and hence let's look at one more 
sample with properties to route all the messages through TCP Monitor. Let's use 
Request/Response type service Invocation.</p>

<h3>Invoking More Than One Service in a Single Client</h3>

<p>Sandesha allows users to write clients that invokes several web services. 
Client can add any number of sequences to the SandeshaContext and RMSouruce will 
handle the underline sequence creation, message delivery and sequence 
termination appropriately. In the following example we will inovke &quot;echoString&quot; 
operation&nbsp; first and invoke &quot;ping&quot; operation passing the response of the &quot;echoString&quot; 
operation. </p>

<p>Note: Please note that in this example both &quot;echoString&quot; and &quot;ping&quot; 
operations are in the same service &quot;RMInteropService&quot; as two different 
operations. However these need NOT be operations of a single service.</p>

<p><source>
public void testEchoPing() throws Exception {
System.out.println("===========Echo and Ping Combined Test Started=============");
UUIDGen uuidGen = UUIDGenFactory.getUUIDGen(); //Can use this for continuous testing.
String str = uuidGen.nextUUID();

Service service = new Service();
Call echoCall = (Call) service.createCall();

SandeshaContext ctx = new SandeshaContext();
//------------------------ECHO------------------------------------------
ctx.addNewSequeceContext(echoCall, targetURL, "urn:wsrm:echoString",
                Constants.ClientProperties.IN_OUT);
ctx.setAcksToUrl(echoCall,
        "http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");
ctx.setReplyToUrl(echoCall,
         "http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");
ctx.setSendOffer(echoCall);

echoCall.setOperationName(new QName("http://tempuri.org/", "echoString"));

echoCall.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);
echoCall.addParameter("arg2", XMLType.XSD_STRING, ParameterMode.IN);
echoCall.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);
//----------------------ECHO----------------------------------------------

//------------------------PING--------------------------------------------
Call pingCall = (Call) service.createCall();
ctx.addNewSequeceContext(pingCall, targetURL, "urn:wsrm:Ping",
      Constants.ClientProperties.IN_ONLY);
ctx.setAcksToUrl(pingCall,
     "http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");

pingCall.setOperationName(new QName("http://tempuri.org/", "ping"));
pingCall.addParameter("arg2", XMLType.XSD_STRING, ParameterMode.IN);
//----------------------PING----------------------------------------------

String ret = (String) echoCall.invoke(new Object[]{"Sandesha Echo 1", str});
System.out.println("The Response for First Messsage is  :" + ret);
pingCall.invoke(new Object[]{ret});

ret = (String) echoCall.invoke(new Object[]{"Sandesha Echo 2", str});
System.out.println("The Response for Second Messsage is  :" + ret);
pingCall.invoke(new Object[]{ret});

ctx.setLastMessage(echoCall);
ret = (String) echoCall.invoke(new Object[]{"Sandesha Echo 3", str});
System.out.println("The Response for Third Messsage is  :" + ret);
ctx.setLastMessage(pingCall);
pingCall.invoke(new Object[]{ret});

RMReport echoReport = ctx.endSequence(echoCall);
RMReport pingReport=ctx.endSequence(pingCall);

assertEquals(echoReport.isAllAcked(), true);
assertEquals(echoReport.getNumberOfReturnMessages(), 3);

assertEquals(pingReport.isAllAcked(), true);
assertEquals(pingReport.getNumberOfReturnMessages(), 0);
System.out.println("===========Echo and Ping Combined Test Finished==========");

}
</source></p>

<p>Note: Samples of all these scenarios are available in the &quot;interop&quot; 
directory. Sample of invoking two web services in a same client is available as 
a test case in the &quot;test&quot; directory.</p>

<h2><font size="5">To Use Sandesha in the Server Side</font></h2>
<p>This can again be done using two steps.</p>
<p>Assume that axis is configured in Tomcat Server </p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to the <b>CATALINA_HOME/webapps/axis/WEB-INF/lib</b> along 
with the other new jars that can be found in <b>target/lib</b> directory of Sandesha.</li>
  <li>To configure Sandesha for a particular service( say MyService) change the 
  <b>deploy.wsdd</b> of <b>&nbsp;MyService</b> according to the following.</li>
</ul>
<p>Note that we have to change the provider to <b>RMProvider</b> and need to add two 
request handlers. A sample of this <b>deploy.wsdd</b> can be found in the interop 
directory named <b>RMInteropServiceDeploy</b> with the required bat file to deploy the 
service. (make sure that the classes for the <b>MyService</b> is copied to 
<b>CATALINA_HOME/webapps/axis/WEB-INF/classes. RMProvider</b> by default will 
use the <b>RPCProvider</b> to invoke the services, however user can specify the 
actual provider that is required to invoke a particular service in <b>
sandesha.properties</b> file that can be found in <b>config</b> directory.</p>

<p><source>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot; 
xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
&nbsp;&lt;service name=&quot;MyService&quot; provider=&quot;Handler&quot;&gt;
&lt;requestFlow&gt;
&lt;handler type=&quot;java:org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler&quot;&gt;&lt;/handler&gt;
&lt;handler type=&quot;java:org.apache.axis.message.addressing.handler.AddressingHandler&quot;&gt;&lt;/handler&gt;
&lt;/requestFlow&gt;
&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.apache.sandesha.ws.rm.providers.RMProvider&quot;/&gt;
&lt;parameter name=&quot;className&quot; value=&quot;test.MyService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;parameter name=&quot;scope&quot; value=&quot;request&quot;/&gt;
&lt;/service&gt;
&lt;/deployment&gt;</source></p>

<h3>Using RMSource Inside a Server</h3>

<p>A common usage of this scenario would be the use of Sandesha from a web 
service that is already deployed in a server. In this scenario the web service 
become the client that utilizes the&nbsp; RMSource for reliable delivery of 
messages. According to the general configuration Sandesha will use a separate 
listener in the client side to &quot;listen for&quot; any acknowledgements or responses 
sent asynchronously to the RMSource. However, the server itself can act as the 
&quot;Listener&quot; for Sandesha. The only aditional requirement is that to deploy &quot;RMService&quot; 
in the same server with &quot;RMClientProvider as the provider. This behavior can 
easily obtained using a deployment descriptor as shown below. </p>

<p><source>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot; 
xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
&lt;service name=&quot;MyService&quot; provider=&quot;java:RPC&quot;&gt;
&lt;parameter name=&quot;className&quot; value=&quot;samples.userguide.example3.MyService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;/service&gt;

&lt;service name=&quot;RMService&quot; provider=&quot;Handler&quot;&gt;
&lt;requestFlow&gt;
&lt;handler type=&quot;java:org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler&quot;&gt;&lt;/handler&gt;
&lt;handler type=&quot;java:org.apache.axis.message.addressing.handler.AddressingHandler&quot;&gt;&lt;/handler&gt;
&lt;/requestFlow&gt;

&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.apache.sandesha.ws.rm.providers.RMClientProvider&quot;/&gt;
&lt;parameter name=&quot;className&quot; value=&quot;org.apache.sandesha.client.RMService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;parameter name=&quot;scope&quot; value=&quot;request&quot;/&gt;
&lt;/service&gt;
&lt;/deployment&gt;
&nbsp;</source></p>

<p>In this deployment descriptor &quot;MyService&quot; is the web service that behaves as 
a client for some other service. (MyService is invoking some other web service 
reliably using Apache Sandesha). To support asynchronous messaging for &quot;MyService&quot; 
using the same server as the Client Side Listener, the user has to deploy &quot;RMService&quot; 
with the above configurations in the same server. In addition to above, &quot;MyService&quot; 
should specify the target URL of the &quot;RMService&quot; when it specify the 
asynchronous endpoint for &lt;wsa:ReplyTo&gt;, &lt;wsrm:AcksTo&gt; , &lt;wsa:FaultTo&gt; etc.. For 
the above sample deployment above URL would be, &quot;<a href="http://host.address:port/axis/services/RMService">http://host.address:port/axis/services/RMService</a>&quot;.</p>

<p>In addition to the above configuration there can be more user specific 
configurations for Sandesha which needs some customizations in the deployment 
level. E.g. Sandesha can be used in the server side, with both RMSource and 
RMDestination to be in the same server.(say, both the service and client are web 
services that are deployed in the same server) For this kind of scenario again 
the user needs &quot;RMService&quot; to be deployed with the above configuration and also 
the web service that acts as the service (not the client service) to be deployed 
with &quot;RMProvider&quot; as the provider. (This is similar to deploying a service to 
use Sandesha)</p>

<h2>Running Samples </h2>

<h3>Build the Sample Classes</h3>
<p>Note : Sandesha build process is done using Apache Maven. So assume that the 
user has already configured Maven in his machine. 
Build process is mainly to run a single Maven command and it is</p>
<p>
<source>maven</source></p>
<p>Since we need the samples also to be build we need one more command (Let's 
use the interop samples)</p>
<p>
<source>maven interop:compile</source></p>
<p>If you need a project to be created for eclipse or Intellij IDEA use the 
maven commands</p>
<p>
<source>maven eclipse</source> </p>
<p><source>maven idea</source> </p>
<h3><font size="4">Run the Inter-op Samples</font></h3>
<p>Go to the directory, interop under the main directory tree. To run the sample 
scenarios we only need to type simple ant commands in a command line.</p>
<p>Followings are the commands to run the samples scenarios.</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="13%">Ant command</td>
    <td width="87%">&nbsp;Description</td>
  </tr>
  <tr>
    <td width="13%">ping_sync</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in same HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">ping_async</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in a different&nbsp; HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_sync_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request and the response&nbsp; come in&nbsp; 
different HTTP Connections. Acknowledgements are coming in the response path of 
    the request's HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_async_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request Acknowledgement and the response&nbsp; come in&nbsp; 
different HTTP Connections.</td>
  </tr>
</table>
<p>In all these scenarios the service <b>RMInteropService</b> is deployed in a
<b>SimpleAxisServer</b> using the ant script and the results will be shown in TCP 
monitors. Please check whether the java processes that is used to invoke TCP 
monitors are not running in the back ground, before every test.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>