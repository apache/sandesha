<html>

<head>
<title>Sandesha User Guide</title>
<style>
.style1 {
	font-family: "Courier New", Courier, mono;
	font-size: 14px;
	color: #990000;
}
</style>
</head>
<body>

<h1><font size="6">User Guide for Apache Sandesha</font></h1>
<p>This document&nbsp; will guide you through the configuration of Sandesha and finally 
to run the sample scenarios.</p>
<h2><font size="5">Configuration</font></h2>
<p>Sandesha can be downloaded as binary or source <a href="releases.html">distributions</a>. This document assumes that 
the user has downloaded the binary distribution, however if you have downloaded 
the source distribution, you can create the binaries by simply running maven 
goal 
&quot;dist-bin&quot;.</p>
<p>Following steps will guide to configure Apache Sandesha on both client and 
server sides.</p>
<h2><font size="5">Use Sandesha in the Client Side</font></h2>
<p>Following two steps will enable the usage of Sandesha in the Client Side.</p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to your classpath (this jar can be found
  in the root directory of the unzipped binary distribution)</li>
  <li>Add the jars in the &quot;lib&quot; directory of the binary distribution to your 
  classpath.</li>
</ul>
<p>There are two main ways that one can use axis to write web service client 
applications.</p>
<ol>
  <li>&nbsp;Using Generated Stubs</li>
  <li>&nbsp;Using Dynamic Invocation Interface (DII)</li>
</ol>
<p>At the moment there is no way that we can inform 
the apache tool (wsdl2java) to generate stubs that are Sandesha aware and hence 
we need to use the DII in order to use Sandesha in the client side. However if 
there are existing stubs, then to use Sandesha with them&nbsp; the user has to 
manually edit the generated stubs to insert properties to the call object.</p>
<h3>Simple  Request-Response&nbsp;Client</h3>
<p>To  use Sandesha in the client side, user has to add few lines to the 
existing client. Following code fragment shows the required additions that one 
should make. </p>
<source><pre>public static void main(String[] args) {
	try {
	Service service = new Service();
	Call call = (Call) service.createCall();
	<span style="background-color: #CCCCCC">SandeshaContext ctx = new SandeshaContext();</span>
	<span style="background-color: #CCCCCC">ctx.initCall(call, targetUrl,</span>
	<span style="background-color: #CCCCCC">"urn:wsrm:echoString",Constants.ClientProperties.IN_OUT);</span>
	call.setOperationName(new QName("http://tempuri.org/", "echoString"));
	call.addParameter("Text", XMLType.XSD_STRING, ParameterMode.IN);
	call.addParameter("Seq", XMLType.XSD_STRING, ParameterMode.IN);
	call.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);

	<span style="background-color: #CCCCCC">ctx.setLastMessage(call);</span>
	String ret = (String) call.invoke(new Object[]{"Sandesha Echo 1", "abcdef"});
	System.out.println("The Response for First Messsage is :" + ret);

	<span style="background-color: #CCCCCC">ctx.endSequence();</span>
	} catch (Exception e) { e.printStackTrace();
	}
}</pre></source></p>
<h4>Explanation on Additions :</h4>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">SandeshaContext ctx = new SandeshaContext();</span></p>
<p>This is the initial step in initializing the&nbsp; RMSource (Client side 
ReliableMessaging Endpoint). SandeshaContext is used to keep track of different 
sequences that the client may create throughout the its lifecycle. Client can 
add any number of call objects to the context.</p>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">ctx.initCall(call,targetUrl ,
                    "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY);</span></p>
<p>Using this step the client can add the call object to the SandeshaContext, 
with targetUrl,&lt;wsa:Action&gt; and the Message Exchange Pattern (MEP) as the 
parameters. Target URL and the action are self-explanatory but may be not the 
MEP. MEP informs Sandesha end point the behavior of the message exchange 
expected by this call object. In other words it helps SandeshaContext to 
understand whether the call object is used for a &quot;Request/Response&quot;&nbsp; 
invocation or &quot;Request Only&quot; invocation. <br>
&nbsp;</p>
<p><span style="font-weight: 700; background-color: #CCCCCC">ctx.setLastMessage(call);</span></p>
<p>This is to inform the RMSource that this message is the last message of a 
particular sequence. Meaning of this statement may not be trivial in the case of 
a single message scenario as above, however this is a &quot;REQUIRED&quot; property for 
RMSource&nbsp; and this will add the &lt;wsrm:LastMessage&gt; header to the outgoing message.</p>
<p>
<span style="font-weight: 700; background-color: #CCCCCC">ctx.endSequence();</span></p>
<p>This is the last statement relating to this invocation sequence. RMSource will 
wait till all the messages been acknowledged and the terminate sequence for this 
particular sequence is sent, before returning the control back to the invocation 
party (that is client). The wait time depends on the policy assertion InactivityTimeout( &lt;wsrm:InactivityTimeout 
Milliseconds=&quot;60000&quot; /&gt; ). If this is the final sequence that is 
available for stopping then the context will wait till all the messages are sent and the 
responses (if any) are received and will stop the client side listener and 
clean up the Sandesha Queue.</p>
<p>Note : These are the minimum changes that one should do in-order to use 
Sandesha in the client side. There are some other additions that one can use to 
get more flexibility in Sandesha and we will see them in the following examples.</p>
<h3>Simple  One-Way Client</h3>
<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation. Again the following code fragment will explain the 
additional code lines required. For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<source><pre>public static void main(String[] args) {
	try {
	Service service = new Service();
	Call call = (Call) service.createCall();

	SandeshaContext ctx = new SandeshaContext();
	ctx.initCall(call,targetUrl ,
    	                "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY);
	call.setOperationName(new QName("http://tempuri.org/", "ping"));
	call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);	
            
	call.invoke(new Object[]{"Sandesha Ping 1"});
	call.invoke(new Object[]{"Sandesha Ping 2"});
	ctx.setLastMessage(call);	
	call.invoke(new Object[]{"Sandesha Ping 3"});
	ctx.endSequence();

	} catch (Exception e) {
	   e.printStackTrace();
	}
}</pre></source></p>

<p>As it can be seen, we need the same additions as above and the explanations 
are the same.</p>

<h3>Simple  One Way Client (Synchronous Acknowledgements)</h3>

<p>In this scenario we will look at how Sandesha can be used in a one-way 
messaging operation using same transport channel to get acknowledgements.&nbsp; For this we use a client that will invoke a 
service 3 times. (This for the explanation purpose only)</p>
<source><pre>public static void main(String[] args) {
	try {
	Service service = new Service();
	Call call = (Call) service.createCall();

	<span style="background-color: #FFFF99">SandeshaContext ctx = new SandeshaContext(Constants.SYNCHRONOUS);</span>
	<span style="background-color: #CCCCCC">ctx.addNewSequeceContext(call,targetUrl ,</span>
		<span style="background-color: #CCCCCC">"urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY</span>);

	call.setOperationName(new QName("http://tempuri.org/", "ping"));
	call.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);

	call.invoke(new Object[]{"Sandesha Ping 1"});
	call.invoke(new Object[]{"Sandesha Ping 2"});
	ctx.setLastMessage(call);
	call.invoke(new Object[]{"Sandesha Ping 3"});
	ctx.endSequence(call);

	} catch (Exception e) {
   		e.printStackTrace();
	}
}</pre></source></p>

<p>The only change we need is to set the flag &quot;sync&quot; to &quot;true&quot; when we add the 
sequence to SandeshaContext, as shown bellow.</p>

<h3><span style="background-color: #FFFF99">SandeshaContext ctx = new SandeshaContext(Constants.SYNCHRONOUS);</span></h3>
<p>By these, client can inform the RMSource, not to start a separate client side 
listener and send the requests with &quot;<b>anonymous URI</b>&quot; in &lt;wsa:From&gt; and &lt;wsrm:AcksTo&gt;&nbsp; 
headers. So the server will use the same transport connection to send Create 
Sequence Response and Acknowledgements.</p>

<p>Note: Please note that this can only be used for One-way operations. If the 
web service request has a response then Sandesha always use a separate listener 
to retrieve the response back.</p>

<h3>Overriding the wsa:Addressing and Other Parameters from Client</h3>

<p>In this section we will look at how we can override the properties specific 
to Sandesha from the client code itself. Sandesha provides complete flexibility 
to the user by allowing them to override properties that are used to set various 
message headers. However it is important to note that the user should set 
appropriate properties (depending on the client, either request-response or one 
way) to get the correct functionality. Following code fragment contains all the 
parameters that the client can set inside the client code.</p>

<source><pre>ctx.setToURL("http://test.organization.com:8080/wsrm/services/rmDemos");
ctx.setFromURL("http://our.organization.org:9070/axis/services/RMService");
ctx.setReplyToURL("http://our.organization.org:9070/axis/services/RMService");
cyx.setAcksToURL("http://our.organization.org:9070/axis/services/RMService");
ctx.setFaultToURL("http://our.organization.org:9070/axis/services/RMService");
ctx.setSendOffer(true);</pre></source></p>

<p>These properties are very useful when debugging applications. By changing 
them appropriately the user can route messages through TCP Monitor or some 
monitor. These properties are self explanatory and hence let's look at one more 
sample with properties to route all the messages through TCP Monitor. Let's use 
Request/Response type service Invocation.</p>

<h3>Invoking More Than One Service in a Single Client</h3>

<p>Sandesha allows users to write clients that invokes several web services. 
Client can add any number of sequences to the SandeshaContext and RMSouruce will 
handle the underline sequence creation, message delivery and sequence 
termination appropriately. In the following example we will inovke &quot;echoString&quot; 
operation&nbsp; first and invoke &quot;ping&quot; operation passing the response of the &quot;echoString&quot; 
operation. </p>

<p>Note: Please note that in this example both &quot;echoString&quot; and &quot;ping&quot; 
operations are in the same service &quot;RMInteropService&quot; as two different 
operations. However these need NOT be operations of a single service.</p>

<source><pre>public void testEchoPing() throws Exception {
    System.out.println("          Echo and Ping Combined Test Started");
    UUIDGen uuidGen = UUIDGenFactory.getUUIDGen(); //Can use this for continuous testing.
    String str = uuidGen.nextUUID();

    Service service = new Service();
    Call echoCall = (Call) service.createCall();

    SandeshaContext ctx = new SandeshaContext();
    //------------------------ECHO--------------------------------------------

    ctx.setAcksToURL("http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");
    ctx.setReplyToURL("http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");
    ctx.setSendOffer(true);
    ctx.initCall(echoCall, targetURL, "urn:wsrm:echoString", Constants.ClientProperties.IN_OUT);

    echoCall.setOperationName(new QName("http://tempuri.org/", "echoString"));
    echoCall.addParameter("arg1", XMLType.XSD_STRING, ParameterMode.IN);
    echoCall.addParameter("arg2", XMLType.XSD_STRING, ParameterMode.IN);
    echoCall.setReturnType(org.apache.axis.encoding.XMLType.XSD_STRING);
    //----------------------ECHO------------------------------------------------

    //------------------------PING--------------------------------------------
    Service pingService = new Service();
    Call pingCall = (Call) pingService.createCall();
    SandeshaContext pingCtx = new SandeshaContext();
    pingCtx.setAcksToURL("http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");
    pingCtx.setReplyToURL("http://127.0.0.1:" + defaultClientPort + "/axis/services/RMService");

    pingCtx.initCall(pingCall, targetURL, "urn:wsrm:Ping", Constants.ClientProperties.IN_ONLY);

    pingCall.setOperationName(new QName("http://tempuri.org/", "ping"));
    pingCall.addParameter("arg2", XMLType.XSD_STRING, ParameterMode.IN);
    //----------------------PING------------------------------------------------

    String ret = (String) echoCall.invoke(new Object[]{" Echo 1 ", str});
    System.out.println("          The Response for First Messsage is  :" + ret);
    pingCall.invoke(new Object[]{ret});

    ctx.setLastMessage(echoCall);
    ret = (String) echoCall.invoke(new Object[]{" Echo 2 ", str});
    System.out.println("          The Response for Second Messsage is  :" + ret);
    pingCall.invoke(new Object[]{ret});

    pingCtx.setLastMessage(pingCall);
    pingCall.invoke(new Object[]{ret});

    RMReport echoReport = ctx.endSequence();
    RMReport pingReport = pingCtx.endSequence();

    assertEquals(echoReport.isAllAcked(), true);
    assertEquals(echoReport.getNumberOfReturnMessages(), 2);

    assertEquals(pingReport.isAllAcked(), true);
    assertEquals(pingReport.getNumberOfReturnMessages(), 0);
    testCount--;
    System.out.println("          Echo and Ping Combined Test Finished");

}
</pre></source></p>

<p>Note: Samples of all these scenarios are available in the &quot;interop&quot; 
directory. Sample of invoking two web services in a same client is available as 
a test case in the &quot;test&quot; directory.</p>

<h2><font size="5">To Use Sandesha in the Server Side</font></h2>
<p>Sandesha configuration in the server side can be explained using two simple 
steps. (Assume that axis is configured in Tomcat Server)</p>
<ul type="square">
  <li>Copy the <b>Sandesha-1.0.jar</b> to the <b>CATALINA_HOME/webapps/axis/WEB-INF/lib</b> along
with the other new jars that can be found in <b>lib</b> directory of Sandesha. 
  (If you are using the Axis1.2 release, then the user have to copy only the 
  &quot;addressing-SNAPTSHOT.jar&quot; additionally)</li>
  <li>To configure Sandesha for a particular service( say MyService) change the 
  <b>deploy.wsdd</b> of <b>&nbsp;MyService</b> according to the following.</li>
</ul>
<p>Note that we have to change the provider to <b>RMProvider</b> and need to add two 
request handlers. A sample of this <b>deploy.wsdd</b> can be found in the sample 
directory named <b>RMSampleServiceDeploy</b> with the required bat file to deploy the 
service. (make sure that the classes for the <b>MyService</b> is copied to <b>CATALINA_HOME/webapps/axis/WEB-INF/classes. RMProvider</b> by default will 
use the <b>RPCProvider</b> to invoke the services, however user can specify the 
actual provider that is required to invoke a particular service in <b>sandesha.properties</b> file that can be found in
<b>Sandesha-1.0.jar</b>.</p>

<source><pre>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot; 
xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
&nbsp;&lt;service name=&quot;MyService&quot; provider=&quot;Handler&quot;&gt;
&lt;requestFlow&gt;
&lt;handler type=&quot;java:org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler&quot;&gt;&lt;/handler&gt;
&lt;handler type=&quot;java:org.apache.axis.message.addressing.handler.AddressingHandler&quot;&gt;&lt;/handler&gt;
&lt;/requestFlow&gt;
&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.apache.sandesha.ws.rm.providers.RMProvider&quot;/&gt;
&lt;parameter name=&quot;className&quot; value=&quot;test.MyService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;parameter name=&quot;scope&quot; value=&quot;request&quot;/&gt;
&lt;/service&gt;
&lt;/deployment&gt;</pre></source></p>

<h3>sandesha.properties</h3>
<p>Following section shows the typical configuration for sandesha.properties. 
Please see the&nbsp; in each property for explanation&nbsp; on that property</p>
<source><pre>
# This is the port in which client side listener listens.
CLIENT_LISTENER_PORT = 9090

# This is the SimpleAxisServerImpl running port. Only for testing purposes.
SIMPLE_AXIS_SERVER_PORT = 8080

# Any number of handlers can be included as shown below for the response path of the Sender. These two are mandatory.
responseHandler1 = org.apache.axis.message.addressing.handler.AddressingHandler
responseHandler2 = org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler

# If there are additional handlers that needs to be included in the Senders request path
# then use the following configuration.
# requestHandler1 = package.name.DummyHandler

# These are the handlers for the Listener's request path. Listener's request path is used to
# retrieve asynchronous responses and other RM protocol messages and hence the handlers we put here
# should be the RESPONSE handlers with respect to normal invocation. These two are mandatory.
listenerRequestHandler1 = org.apache.axis.message.addressing.handler.AddressingHandler
listenerRequestHandler2 = org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler

# Define the strategy for executing web service invokes.D
# This impl uses the apache axis thread pool and configures
# it to the given size.
invokeStrategy=org.apache.sandesha.server.ThreadPoolInvokeStrategy:threadPoolSize=10

# Define the invoke handler that will execute the web service invokes.
# This impl simply delegates to the handler specified by the "invoker" param.
invokeHandler=org.apache.sandesha.server.DelegateInvokeHandler:invoker=org.apache.axis.providers.java.RPCProvider
</pre></source></p>
<h3>Using RMSource Inside a Server</h3>

<p>A common usage of this scenario would be the use of Sandesha from a web 
service that is already deployed in a server. In this scenario the web service 
become the client that utilizes the&nbsp; RMSource for reliable delivery of 
messages. According to the general configuration Sandesha will use a separate 
listener in the client side to &quot;listen for&quot; any acknowledgements or responses 
sent asynchronously to the RMSource. However, the server itself can act as the 
&quot;Listener&quot; for Sandesha. The only aditional requirement is that to deploy &quot;RMService&quot; 
in the same server with &quot;RMClientProvider as the provider. This behavior can 
easily obtained using a deployment descriptor as shown below. </p>

<source><pre>&lt;deployment xmlns=&quot;http://xml.apache.org/axis/wsdd/&quot; 
xmlns:java=&quot;http://xml.apache.org/axis/wsdd/providers/java&quot;&gt;
&lt;service name=&quot;MyService&quot; provider=&quot;java:RPC&quot;&gt;
&lt;parameter name=&quot;className&quot; value=&quot;samples.userguide.example3.MyService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;/service&gt;

&lt;service name=&quot;RMService&quot; provider=&quot;Handler&quot;&gt;
&lt;requestFlow&gt;
&lt;handler type=&quot;java:org.apache.sandesha.ws.rm.handlers.RMServerRequestHandler&quot;&gt;&lt;/handler&gt;
&lt;handler type=&quot;java:org.apache.axis.message.addressing.handler.AddressingHandler&quot;&gt;&lt;/handler&gt;
&lt;/requestFlow&gt;

&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.apache.sandesha.ws.rm.providers.RMClientProvider&quot;/&gt;
&lt;parameter name=&quot;className&quot; value=&quot;org.apache.sandesha.client.RMService&quot;/&gt;
&lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
&lt;parameter name=&quot;scope&quot; value=&quot;request&quot;/&gt;
&lt;/service&gt;
&lt;/deployment&gt;
&nbsp;</pre></source></p>

<p>In this deployment descriptor &quot;MyService&quot; is the web service that behaves as 
a client for some other service. (MyService is invoking some other web service 
reliably using Apache Sandesha). To support asynchronous messaging for &quot;MyService&quot; 
using the same server as the Client Side Listener, the user has to deploy &quot;RMService&quot; 
with the above configurations in the same server. In addition to above, &quot;MyService&quot; 
should specify the target URL of the &quot;RMService&quot; when it specify the 
asynchronous endpoint for &lt;wsa:ReplyTo&gt;, &lt;wsrm:AcksTo&gt; , &lt;wsa:FaultTo&gt; etc.. For 
the above sample deployment above URL would be, &quot;<a href="http://host.address:port/axis/services/RMService">http://host.address:port/axis/services/RMService</a>&quot;.</p>

<p>In addition to the above configuration there can be more user specific 
configurations for Sandesha which needs some customizations in the deployment 
level. E.g. Sandesha can be used in the server side, with both RMSource and 
RMDestination to be in the same server.(say, both the service and client are web 
services that are deployed in the same server) For this kind of scenario again 
the user needs &quot;RMService&quot; to be deployed with the above configuration and also 
the web service that acts as the service (not the client service) to be deployed 
with &quot;RMProvider&quot; as the provider. (This is similar to deploying a service to 
use Sandesha)</p>

<h2>Running Samples </h2>

<p>To test the samples automatically, execute the following ant targets provided in the &quot;build.xml&quot; file in 
the samples directory. If you have downloaded the source distribution and need 
to run the samples, please build the source first using the maven.</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="13%">Ant command</td>
    <td width="87%">&nbsp;Description</td>
  </tr>
  <tr>
    <td width="13%">ping_sync</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in same HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">ping_async</td>
    <td width="87%">The scenario tests the simple one way Ping operation with 
    acknowledgements coming in a different&nbsp; HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_sync_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request and the response&nbsp; come in&nbsp; 
different HTTP Connections. Acknowledgements are coming in the response path of 
    the request's HTTP connection</td>
  </tr>
  <tr>
    <td width="13%">echo_async_ack</td>
    <td width="87%">This scenario tests the simple two way Echo String 
    operation. Here the request Acknowledgement and the response&nbsp; come in&nbsp; 
different HTTP Connections.</td>
  </tr>
</table>
<p>In all these scenarios the service <b>RMSampleService</b> is deployed in a <b>SimpleAxisServer</b> 
using the ant script and the results will be shown in TCP monitors. </p>
<p>In addition Sandesha-samples.jar that contains all the samples can be found 
in the samples directory.</p>
<p>If you need a project to be created for Eclipse or Intellij IDEA use the 
maven commands</p>
<p>
<source>maven eclipse</source> </p>
<p><source>maven idea</source> </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>